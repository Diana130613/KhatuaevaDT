# Тема 11. Алгоритмы на строках

## Цель работы

Цель работы – изучить специализированные алгоритмы обработки строк: префикс‑функцию, алгоритм Кнута–Морриса–Пратта (KMP), Z‑функцию и дополнительные алгоритмы поиска подстроки. В ходе практики реализуются и сравниваются несколько алгоритмов поиска подстрок, исследуется их производительность на разных типах входных данных, а также решаются практические задачи (поиск всех вхождений, поиск периода строки, проверка циклического сдвига).

## Характеристики аппаратной и программной среды

- Операционная система: Microsoft Windows 11 Домашняя для одного языка  
- Тип системы: x64  
- Модель устройства: HUAWEI (серия FLMH-XX-PCB / C170)  
- Процессор: Intel Core Ultra 7 155H, базовая частота 3.8 ГГц, 16 логических ядер  
- Оперативная память (установлено): 16 ГБ  
- Интерпретатор Python: 3.x (64‑bit)  

Все замеры производительности проводились на одной и той же машине и в одинаковых условиях запуска.

## Структура проекта

Единый модуль `string_algorithms.py` (или набор файлов по методичке) содержит:

- `prefix_function(s)` – вычисление префикс‑функции  
- `kmp_search(text, pattern)` – поиск подстроки алгоритмом KMP  
- `z_function(s)` – вычисление Z‑функции  
- `z_search(text, pattern)` – поиск подстроки с использованием Z‑функции  
- `naive_search(text, pattern)` – наивный алгоритм поиска подстроки  
- `rabin_karp(text, pattern)` – алгоритм Рабина–Карпа  
- `find_period(s)` – поиск наименьшего периода строки  
- `is_cyclic_shift(a, b)` – проверка, является ли одна строка циклическим сдвигом другой  
- `benchmark()` – базовое сравнение времени работы наивного поиска и KMP  
- функция `main()` – демонстрация работы всех алгоритмов и вывод результатов

Код оформлен в соответствии с PEP 8: отступы в 4 пробела, имена функций и переменных в стиле `snake_case`, короткие комментарии, поясняющие сложность и назначение.

## Реализованные алгоритмы

### Префикс‑функция

Функция `prefix_function(s)` строит массив π длины `n`, где `π[i]` – длина наибольшего собственного префикса строки `s`, совпадающего с суффиксом подстроки `s[0..i]`.

- Время: O(n)  
- Память: O(n)  

Префикс‑функция используется далее в алгоритме KMP и в задаче поиска периода строки.

### Алгоритм Кнута–Морриса–Пратта (KMP)

Функция `kmp_search(text, pattern)` реализует поиск всех вхождений подстроки `pattern` в строке `text`. Реализация использует префикс‑функцию для строки `pattern + "#" + text` и по значениям π определяет позиции совпадений.

- Время: O(n + m), где `n` – длина текста, `m` – длина паттерна  
- Память: O(m) для хранения префикс‑функции  

KMP избегает повторных сравнений, «сдвигая» паттерн на длину уже совпавшего префикса.

### Z‑функция и поиск через неё

Функция `z_function(s)` для каждой позиции i вычисляет длину наибольшего общего префикса строки `s` и её суффикса, начинающегося в i.

- Время: O(n)  
- Память: O(n)  

На её основе реализован поиск подстроки `z_search(text, pattern)`: строится строка `pattern + "#" + text`, вычисляется Z‑функция, и позиции, где `z[i] == len(pattern)`, соответствуют вхождениям паттерна.

### Наивный поиск

Функция `naive_search(text, pattern)` последовательно сравнивает паттерн со всеми подстроками текста.

- Худший случай: O(n · m) по времени  
- Память: O(1) дополнительно  

Используется как базовый алгоритм для сравнения с KMP и другими методами.

### Алгоритм Рабина–Карпа

Функция `rabin_karp(text, pattern)` реализована на основе полиномиального хэша с модулем. Для каждого окна длины `m` в тексте поддерживается скользящий хэш; при совпадении хэшей выполняется точная проверка подстроки.

- Среднее время: O(n + m)  
- Худший случай: O(n · m) при частых коллизиях  
- Память: O(1) дополнительно  

Преимущество – возможность поиска нескольких паттернов и эффективная реализация на больших алфавитах.

## Практические задачи

В рамках работы решены следующие задачи:

1. **Поиск всех вхождений паттерна в тексте.**  
   Реализован наивный алгоритм, KMP, Z‑поиск и Рабин–Карп. Все алгоритмы демонстрируются на тесте  
   `text = "ababcababcababc"`, `pattern = "ababc"`, где вхождения найдены на позициях 0, 5, 10.

2. **Поиск периода строки.**  
   Функция `find_period(s)` использует префикс‑функцию: период существует, если `n % (n - π[n-1]) == 0`.  
   Для строки `abcabcabcabc` найден период длины 3.

3. **Проверка циклического сдвига.**  
   Функция `is_cyclic_shift(a, b)` проверяет, является ли `b` циклическим сдвигом `a`, с помощью поиска подстроки в строке `a + a`.  
   Пример: `abcd` и `cdab` – циклические сдвиги.

При необходимости эти функции можно использовать для задач поиска шаблонов, анализа периодичности сигналов, сравнения циклически сдвинутых последовательностей.

## Экспериментальные результаты

Для демонстрации сравнительной эффективности наивного поиска и KMP используется функция `benchmark()`.

Параметры теста:

- текст: строка из 10000 повторений `ab` и завершающего `aba`  
- паттерн: `aba`

Результаты одного из запусков:

- Наивный поиск:  
  - количество вхождений: 10001  
  - время ≈ 0.006 с
- KMP:  
  - количество вхождений: 10001  
  - время ≈ 0.007 с

Оба алгоритма находят одинаковое число вхождений. На данном тесте преимущества KMP по времени не проявляются, так как структура строки и паттерна благоприятна и для наивного алгоритма. На строках с большим числом самопересечений паттерна ожидается заметное преимущество KMP.

Для полноты лабораторной работы рекомендуется дополнительно:

- варьировать длину текста и паттерна;  
- строить графики «длина текста → время работы» для наивного поиска, KMP и Рабина–Карпа;  
- рассматривать худшие и лучшие случаи (например, периодические строки, случайные строки, строки с длинными префиксами/суффиксами).

## Краткие ответы на контрольные вопросы

1. **Префикс‑функция и её использование в KMP.**  
   Префикс‑функция для каждой позиции i даёт длину наибольшего собственного префикса, совпадающего с суффиксом префикса строки. В KMP она позволяет при несовпадении не возвращаться назад по тексту, а сдвигать паттерн на длину «наибольшего совпавшего префикса».

2. **Преимущество KMP перед наивным поиском.**  
   Наивный алгоритм в худшем случае делает O(n · m) сравнений, многократно сравнивая одинаковые префиксы. KMP запоминает информацию о совпавших префиксах с помощью префикс‑функции и обеспечивает асимптотику O(n + m), не повторяя сравнения уже проверенных символов.

3. **Z‑функция и поиск подстроки.**  
   Z‑функция измеряет, насколько длинный префикс строки совпадает с её суффиксом, начинающимся с каждой позиции. Если рассмотреть строку `pattern + "#" + text`, то позиции, где Z‑значение равно длине паттерна, соответствуют вхождениям паттерна в тексте.

4. **Идея алгоритма Бойера–Мура (для сравнения с реализованными).**  
   Бойер–Мур сравнивает паттерн с текстом справа налево и использует эвристику «плохого символа» и «хорошего суффикса» для максимального сдвига паттерна вперёд при несовпадении, что даёт хорошую производительность на практике для больших алфавитов.

5. **Другие применения префикс‑ и Z‑функций.**  
   Поиск периода строки, подсчёт числа различных подстрок, сжатие данных, поиск повторяющихся фрагментов, задачи по совпадению шаблонов в биоинформатике (поиск мотивов в ДНК‑последовательностях).

## Выводы

В ходе работы были реализованы и исследованы несколько алгоритмов обработки строк: префикс‑функция, KMP, Z‑функция, наивный поиск и Рабин–Карп. На примерах показано, что специализированные алгоритмы (KMP, Z‑поиск, Рабин–Карп) позволяют гарантировать линейное время в общем случае и эффективны для больших текстов и паттернов с повторяющейся структурой. Выполнены практические задачи по поиску всех вхождений подстроки, определению периода строки и проверке циклического сдвига, что демонстрирует широкую применимость алгоритмов на строках.
