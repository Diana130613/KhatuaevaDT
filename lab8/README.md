# Тема 08: Жадные алгоритмы

## Цель работы: 
Изучить метод проектирования алгоритмов, известный как "жадный алгоритм". Освоить принцип принятия локально оптимальных решений на каждом шаге и понять условия, при которых этот подход приводит к глобально оптимальному решению. Получить практические навыки реализации жадных алгоритмов для решения классических задач, анализа их корректности и оценки эффективности.

## Задание:
1. Реализовать классические жадные алгоритмы.
2. Проанализировать их корректность (доказать или объяснить, почему жадный выбор приводит к оптимальному решению).
3. Провести сравнительный анализ эффективности жадного подхода и других методов (например, полного перебора для маленьких входных данных).
4. Решить практические задачи с применением жадного подхода.

## Шаги выполнения:
1. Создание проекта
Создать файлы greedy_algorithms.py, analysis.py.

2. Реализация жадных алгоритмов (в greedy_algorithms.py)  
- Задача о выборе заявок (Interval Scheduling)
  - Реализовать функцию, которая выбирает максимальное количество непересекающихся интервалов из заданного списка. (Жадный выбор: сортировка по времени окончания и выбор следующего рано заканчивающегося непересекающегося интервала).

- Непрерывный рюкзак (Fractional Knapsack)
  - Реализовать функцию, которая максимизирует стоимость содержимого рюкзака, если можно брать дробные части предметов. (Жадный выбор: сортировка по удельной стоимости (цена/вес) и взятие большего количества лучших предметов).

- Алгоритм Хаффмана (Huffman Coding)
  - Реализовать алгоритм построения оптимального префиксного кода для заданных частот символов.

Для каждого алгоритма указать его временную сложность и объяснить, почему жадный выбор корректен.

3. Анализ корректности (в README.md)
Для каждой задачи кратко объяснить, почему жадная стратегия приводит к оптимальному результату.

4. Сравнительный анализ (в analysis.py)
Для задачи о рюкзаке: сравнить результат жадного алгоритма для непрерывной версии с результатом точного алгоритма (например, полным перебором или ДП) для дискретной версии (0-1) на маленьких входных данных. Показать, что для дискретной задачи жадный подход может давать неоптимальный результат.

5. Решение задач
- Решить задачу о минимальном количестве монет для выдачи сдачи (жадный алгоритм работает не для всех систем монет, реализовать для стандартной системы).

- Реализовать алгоритм Прима или Краскала для нахождения минимального остовного дерева (по желанию, для продвинутых).

6. Экспериментальное исследование  
Замерить время работы алгоритма Хаффмана на данных разного размера.
ВАЖНО: Все замеры проводить на одной вычислительной машине.

7. Визуализация
- Построить дерево кодов Хаффмана.
- Построить график зависимости времени работы алгоритма от размера входных данных.

8. Анализ результатов
- Сравнить эффективность жадных алгоритмов с наивными реализациями.
- Обсудить ограничения жадного подхода.

9. Оформление отчета  
Результаты оформить в файле README.md. Код должен соответствовать
PEP8.