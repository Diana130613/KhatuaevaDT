# Отчет по лабораторной работе 8
# Жадные алгоритмы

**Дата:** 2025-12-19   
**Семестр:** 3 курс 1 полугодие - 5 семестр  
**Группа:** ПИЖ-б-о-23-2(1)  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Хатуаева Дайана Тныбековна

## Цель работы
Изучить метод проектирования алгоритмов, известный как "жадный алгоритм". Освоить принцип принятия локально оптимальных решений на каждом шаге и понять условия, при которых этот подход приводит к глобально оптимальному решению. Получить практические навыки реализации жадных алгоритмов для решения классических задач, анализа их корректности и оценки эффективности.

## Теоретическая часть
- **Жадный алгоритм:** Алгоритм, который на каждом шаге принимает **локально оптимальное** решение в надежде, что итоговое решение будет глобально оптимальным.
- **Ключевые характеристики:**
  - **Жадный выбор:** На каждом шаге выбирается лучший из доступных вариантов в данный момент, без учета последствий для будущих шагов.
  - **Оптимальная подструктура:** Оптимальное решение задачи содержит в себе оптимальные решения её подзадач.
- **Области применения:** Жадные алгоритмы эффективны для задач, где выбор, сделанный на каждом шаге, не ухудшает возможности достижения глобального оптимума. Они часто работают быстро (полиномиальное время), но не всегда приводят к оптимальному решению.
- **Классические задачи:**
  - **Задача о выборе заявок (Interval Scheduling):** Выбор максимального количества непересекающихся интервалов.
  - **Задача о рюкзаке (Непрерывная/Дробная):** Выбор предметов с максимальной суммарной стоимостью, если можно брать части предметов.
  - **Алгоритм Хаффмана:** Оптимальное префиксное кодирование для сжатия данных.
  - **Построение минимального остовного дерева (Алгоритмы Прима и Краскала):** (Хотя это и графовый алгоритм, он является классическим примером жадного подхода).

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализовать классические жадные алгоритмы.
- [x] Задача 2: Проанализировать их корректность (доказать или объяснить, почему жадный выбор приводит к
оптимальному решению).
- [x] Задача 3: Провести сравнительный анализ эффективности жадного подхода и других методов (например,
полного перебора для маленьких входных данных).
- [x] Задача 4: Решить практические задачи с применением жадного подхода.

### Ключевые фрагменты кода

#### Реализация жадных алгоритмов
В greedy_algorithms.py необходимо реализовать несколько алгоритмов.

##### Задача о выборе заявок (Interval Scheduling):
— это классическая задача оптимизации, где нужно выбрать максимальное количество непересекающихся по времени заявок из заданного набора, чтобы они не конфликтовали, а ресурсы были использованы эффективно. Решается она так: отбирается заявка, которая заканчивается раньше всех, затем следующая из оставшихся, не пересекающаяся с первой, и так далее, заявки сортируются по времени завершения. 
```python
# greedy_algorithms
def interval_scheduling(intervals):
    """
    Задача о выборе заявок: ищем макс. множество непересекающихся интервалов.
    Жадный выбор — сортировка по времени окончания.

    Args:
        intervals: Список интервалов в формате (начало, конец)

    Returns:
        Список выбранных интервалов в том же формате

    Сложность: O(n log n)
    """
    # Анонимная функция возвращает 2-й элемент
    intervals = sorted(intervals, key=lambda x: x[1])

    result = []
    last_end = float('-inf')
    for start, end in intervals:
        if start >= last_end:
            result.append((start, end))
            last_end = end
    return result
```

#### Непрерывный рюкзак (Fractional Knapsack):
Принцип работы: функция, которая максимизирует стоимость содержимого рюкзака, если можно брать дробные части предметов. Жадный выбор: сортировка по удельной стоимости (цена/вес) и взятие большего количества лучших предметов.
```python
# greedy_algorithms
def fractional_knapsack(weights, values, capacity):
    """
    Задача о рюкзаке: можно брать дробные части предметов.
    Жадный выбор — сортировка по удельной стоимости (value/weight).

    Args:
        weights: Веса предметов
        values: Стоимости предметов
        capacity: Вместимость рюкзака

    Returns:
        Максимальная стоимость, которую можно унести

    Сложность: O(n log n)
    """
    # Список троек: удельная стоимость, вес, стоимость
    items = sorted(
        ((v / w, w, v) for w, v in zip(weights, values)),
        reverse=True
    )

    total = 0
    for ratio, weight, value in items:
        if capacity == 0:
            break

        # Берем максимально возможное количество текущего предмета
        take = min(weight, capacity)
        total += ratio * take
        capacity -= take

    return total
```

#### Алгоритм Хаффмана (Huffman Coding)
— это алгоритм сжатия данных.
Суть алгоритма в построении специального двоичного дерева, где каждый символ получает уникальную комбинацию битов, зависящую от частоты появления в исходной последовательности.
```python
# greedy_algorithms
class HuffmanNode:
    """
    Класс узла дерева Хаффмана.

    Attributes:
        char: Символ (None для внутренних узлов)
        freq: Частота символа
        left: Левый потомок
        right: Правый потомок
    """
    def __init__(self, char, freq, left=None, right=None):
        self.char = char  # листовые узлы
        self.freq = freq
        self.left = left
        self.right = right

    def __lt__(self, other):
        # для heapq
        return self.freq < other.freq


def huffman_code(freqs):
    """
    Алгоритм Хаффмана: минимальное префиксное кодирование.
    Жадный выбор — объединяем узлы с наименьшими частотами.

    Args:
        freqs: Словарь символ->частота

    Returns:
        Кортеж (словарь кодов, корень дерева)

    Сложность: O(n log n)
    """
    heap = [HuffmanNode(char, freq) for char, freq in freqs.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        a = heapq.heappop(heap)
        b = heapq.heappop(heap)
        heapq.heappush(
            heap,
            HuffmanNode(None, a.freq + b.freq, a, b)
        )
    root = heap[0]
    codes = {}

    def gen_codes(node, prefix=""):
        if node.char is not None:
            codes[node.char] = prefix
        else:
            gen_codes(node.left, prefix + "0")
            gen_codes(node.right, prefix + "1")
    gen_codes(root)

    return codes, root


def print_huffman_tree(node, indent=""):
    """
    Визуализация дерева Хаффмана (рекурсивный вывод).

    node: Текущий узел для вывода
    indent: Отступ для текущего уровня
    """
    if node.char is not None:  # Если достигли листа
        print(indent + repr(node.char) + f":{node.freq}")
    else:
        print(indent + "*")
        print_huffman_tree(node.left, indent + "  ")
        print_huffman_tree(node.right, indent + "  ")
```

#### Сравнительный анализ (в analysis.py)
Для задачи о рюкзаке: сравнить результат жадного алгоритма для непрерывной версии с
результатом точного алгоритма (например, полным перебором или ДП) для дискретной
версии (0-1) на маленьких входных данных. Показать, что для дискретной задачи жадный
подход может давать неоптимальный результат.

```python
# analysis.py
import itertools
from .greedy_algorithms import fractional_knapsack


def brute_force_01_knapsack(weights, values, capacity):
    """Полный перебор для задачи 0-1 рюкзака"""
    n = len(weights)
    best_value = 0
    best_combination = None

    # Перебираем все возможные комбинации предметов
    for r in range(n + 1):
        for combo in itertools.combinations(range(n), r):
            total_weight = sum(weights[i] for i in combo)
            total_value = sum(values[i] for i in combo)

            if total_weight <= capacity and total_value > best_value:
                best_value = total_value
                best_combination = combo
    return best_value, best_combination


def compare_knapsack():
    """Сравнение дробного и дискретного рюкзаков"""
    weights = [10, 20, 30]
    values = [60, 100, 120]
    capacity = 50

    # Дробный рюкзак (жадный)
    fractional_val = fractional_knapsack(weights, values, capacity)

    # Дискретный рюкзак (полный перебор)
    discrete_val, combo = brute_force_01_knapsack(weights, values, capacity)

    print("Сравнение рюкзаков:")
    print(f"Веса: {weights}, Стоимости: {values}, Вместимость: {capacity}")
    print(f"Дробный рюкзак (жадный): {fractional_val:.2f}")
    print(f"Дискретный рюкзак (0-1): {discrete_val}")
    print(f"Комбинация для 0-1: {combo}")

    # Пример, где жадный алгоритм для 0-1 не оптимален
    print("\nПример неоптимальности жадного для 0-1:")
    weights2 = [30, 20, 10]
    values2 = [120, 100, 60]

    # Жадное решение для 0-1 (берём по убыванию удельной стоимости)
    items = sorted(zip(values2, weights2),
                   key=lambda x: x[0]/x[1], reverse=True)

    cap = 50
    greedy_01_val = 0
    greedy_01_weight = 0

    for v, w in items:
        if greedy_01_weight + w <= cap:
            greedy_01_val += v
            greedy_01_weight += w

    # Оптимальное решение
    opt_val, opt_combo = brute_force_01_knapsack(weights2, values2, cap)

    print(f"Жадный для 0-1: {greedy_01_val}")
    print(f"Оптимальный для 0-1: {opt_val}")
    print(f"Разница: {opt_val - greedy_01_val}")
```

####  Задача
Решить задачу о минимальном количестве монет для выдачи сдачи.

```python
# task_solution
def min_coins(amount, coins):
    """
    Жадный алгоритм минимального числа монет для сдачи.

    Args:
        amount: Сумма для размена
        coins: Доступные номиналы монет

    Returns:
        Список монет для размена или None если размен невозможен

    Сложность: O(n) (число типов монет)
    """
    coins = sorted(coins, reverse=True)  # Сортировка по убывания номинала
    result = []

    for coin in coins:
        while amount >= coin:
            amount -= coin
            result.append(coin)

    # Если не смогли разменять полностью
    if amount > 0:
        return None
    return result
```

####  Экспериментальное исследование и Визуализация

```python
# performance_analysis.py

```

### Экспериментальное исследование
- Замерить время выполнения операций для разных коэффициентов заполнения (0.1, 0.5, 0.7, 0.9)
- Исследовать влияние качества хеш-функции на количество коллизий
- Все замеры проводить на одной вычислительной машине

```python
import time
import random
import matplotlib.pyplot as plt
from .greedy_algorithms import huffman_code


def perf_huffman():
    """
    Эксперимент по замеру времени работы алгоритма Хаффмана.
    """
    # Размеры алфавита для тестирования
    sizes = [50, 100, 500, 1000, 3000]
    times = []

    for size in sizes:
        freqs = {str(i): random.randint(10, 1000) for i in range(size)}
        t0 = time.time()
        codes, _ = huffman_code(freqs)
        t1 = time.time()
        times.append(t1 - t0)
    fig, ax = plt.subplots(figsize=(8, 5))
    ax.plot(sizes, times, label='Время кодирования Хаффмана')
    ax.set_xlabel('Размер алфавита (количество символов)')
    ax.set_ylabel('Время выполнения (секунды)')
    ax.set_title('Зависимость времени работы алгоритма Хаффмана от размера алфавита')
    ax.legend()
    plt.savefig('huffman_time.png', dpi=150)
    plt.close()

    return sizes, times
```

## Результаты выполнения

### Пример работы программы
```

```

![Текст](./report/collisions_compare.png)

![Текст](./report/hash_dist.png)

![Текст](./report/perf_insert.png)

![Текст](./report/perf_search.png)


## Ответы на контрольные вопросы
1. В чём заключается основная идея жадных алгоритмов?


2. Для задачи о выборе заявок (Interval Scheduling) жадный алгоритм, выбирающий интервалы с наименьшим временем окончания, является оптимальным. Объясните, почему эта жадная стратегия работает.


3. Приведите пример задачи, для которой жадный алгоритм дает оптимальное решение, и задачи, для которой он не дает.
4. В чём разница между непрерывной (дробной) и дискретной (0-1) задачами о рюкзаке? Для какой из них жадный алгоритм оптимален?


5. Опишите жадный алгоритм построения кода Хаффмана. В чём его оптимальность?
