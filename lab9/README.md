# Тема 09: Динамическое программирование

## Цель работы: 
Изучить метод динамического программирования (ДП) как мощный инструмент для решения сложных задач путём их разбиения на перекрывающиеся подзадачи. Освоить два основных подхода к реализации ДП: нисходящий (с мемоизацией) и восходящий (с заполнением таблицы). Получить практические навыки выявления оптимальной подструктуры задач, построения таблиц ДП и анализа временной и пространственной сложности алгоритмов.

## Задание:
1. Реализовать классические алгоритмы динамического программирования.
2. Реализовать оба подхода (нисходящий и восходящий) для решения задач.
3. Провести сравнительный анализ эффективности двух подходов.
4. Проанализировать временную и пространственную сложность алгоритмов.
5. Решить практические задачи с применением ДП.

## Шаги выполнения:
1. Создание проекта: Создать файлы dynamic_programming.py, comparison.py.

2. Реализация алгоритмов ДП (в dynamic_programming.py):
- Числа Фибоначчи:
  - Реализовать наивную рекурсию, рекурсию с мемоизацией и итеративное табличное решение.
- Задача о рюкзаке (0-1 Knapsack):
  - Реализовать восходящий подход с заполнением 2D-таблицы dp[i][w].
- Наибольшая общая подпоследовательность (LCS):
  - Реализовать восходящий подход с заполнением 2D-таблицы dp[i][j].
- Расстояние Левенштейна:
  - Реализовать восходящий подход с заполнением 2D-таблицы dp[i][j].
- Для каждого алгоритма указать его временную и пространственную сложность.

3. Сравнительный анализ (в comparison.py):
- Сравнить время работы и потребление памяти нисходящего (с мемоизацией) и восходящего подхода для вычисления чисел Фибоначчи для больших n.
- Сравнить результат жадного алгоритма для непрерывного рюкзака с результатом ДП для задачи о рюкзаке 0-1.

4. Восстановление решения:
Для задачи LCS или рюкзака реализовать функцию не только для нахождения значения
(длины/стоимости), но и для восстановления самой подпоследовательности/набора
предметов.

5. Решение задач:
- Решить задачу "Размен монет" (минимальное количество монет для суммы) с помощью ДП.
- Решить задачу "Наибольшая возрастающая подпоследовательность (LIS)".

6. Экспериментальное исследование:
- Исследовать масштабируемость алгоритмов ДП (например, рюкзака) при увеличении размера входных данных.
ВАЖНО: Все замеры проводить на одной вычислительной машине.

7. Визуализация:
- Визуализировать процесс заполнения таблицы ДП для небольших входных данных (например, выводить таблицу на каждом шаге или в конце).
- Построить графики зависимости времени выполнения от размера задачи.

8. Анализ результатов:
- Сравнить эффективность разных подходов ДП.
- Проанализировать, как увеличение параметров задачи влияет на время и память.
